import random
import re

from PIL import Image
from nonebot import on_command, on_message, on_notice, require, get_driver, on_regex, on_keyword, on_startswith
from nonebot.typing import T_State
from nonebot.adapters.cqhttp import Message, Event, Bot
from src.libraries.image import *
from random import randint
import requests
import html2text
from aiocqhttp.message import MessageSegment

help = on_command('!help')


@help.handle()
async def _(bot: Bot, event: Event, state: T_State):
    help_str = '''Eurobot 食用方法：
今日运势 :查看今天的舞萌运势 （附赠音击抽卡）
XXXmaiXXX什么 :随机一首歌
bp (为了分开不是b40) : 查询b40
例：bp Europix

随个[dx/标准][绿黄红紫白]<难度> :随机一首指定条件的乐曲
例：随个紫12

查歌<乐曲标题的一部分> :查询符合条件的乐曲
例：(!)查歌 起動音

[绿黄红紫白]id<歌曲编号> :查询乐曲信息或谱面信息
例：紫id220

<歌曲别名>是什么歌 :查询乐曲别名对应的乐曲
例：启动音是什么歌

定数查歌 <定数>  :查询定数对应的乐曲
例：(!)定数查歌 12.3

分数线 <难度+歌曲id> <分数线> 详情请输入“分数线 帮助”查看
例：!分数线 紫id220 100.50

!查分 <歌曲id> 可查询自己某歌分数 (需要在查分器绑定qq)
例：!查分 220 / !me 220

分数列表 <等级> （上下限） 可以输出某个等级某个范围内的分数列表
例： !filter 13 （13级的分数列表）
    !分数列表 13+ 100.0 （13+大于100的分数列表）
    !分数列表 14 99.90 100.00 （14级位于99.9和鸟之间的分数列表）
    
排行榜 <歌曲id> （难度） 可以输出某首歌 紫谱 的排行榜（本地）
例： 排行榜 220 （没有感叹号）
例： 排行榜 834 白 (白谱)
*注 排行榜会显示第一名的qq，和自己的分数，若介意可以联系主人删除数据

!update 更新自己的数据
例： !update
*注 如果想删除自己的数据请联系主人 qq759381653

石(凯，财，风) 数字/几 :可实时报告或追踪机厅人数
例：石 5/石 几

随机上/下/中/特级：模拟 Splash 随机段位四首歌
例: 随机上级 （*特级为超上级）

每次出勤记录：记录每次出勤推分（和本地数据/上次更新数据对比）
例：!r
特殊说明：!r的数据是和本地数据对比，所以可能会有以下情况
1. 本地没有数据 -> 你需要!update来初始化数据
2. !r没有任何数据 -> 你没推分/没更新查分器/先更新的本地数据再更新查分器
3. 突然出现很多数据 -> 你可能是(很久)没有更新过，可以看看下面的正确方法
正确使用方法：
!update 初始化数据 -> 更新查分器（水鱼）-> !r -> !update

安慰分/查安慰分 <定数>/我想吃安慰分：去看如何在鸟加之前多吃1分
例: 安慰分
例：查安慰分 14.7
例：我想吃安慰分 (需要查分器绑定qq & 在本地!update过)

骂我/ 本期课题 / 随个朱云杰 / 今天吃什么 / 随个吉安娜(不)推荐歌
还有 神秘命令 Eurobot等你使用哦

5.28新增音击支持！
音击查歌 <歌名>：查询音击歌曲(大小写不敏感，可模糊搜索)
例：音击查歌 liftoff

音击抽卡：随机一张音击卡片！暂时是随便抽，卡池约3000张
例：音击抽卡 
*目前很多人抽卡，可能会出现高并发导致bot没有回复，再发一遍就好
*本抽卡概率均等（r/sr/ssr出货概率相当），与sega没有任何利益关系

随个音击/随首音击：随机一个音击歌曲
例：随个音击
 ------------------------------------------
Akatsuki Relax 查分 食用指南：
!rrc <玩家uid> 最近一次游玩结果（图片）
!rbp <bp多少> <玩家uid> 查询玩家的某个bp （图片）
!todaybp <玩家uid> 今天打出来的bp (1-100)
以上只用于 osu! Akatsuki 服的 relax 模式！
made by chiyuki & Europix  主人：深海少女吉安娜
version 2.0  updated on 2022.4.7'''

    await help.send(Message([{
        "type": "image",
        "data": {
            "file": f"base64://{str(image_to_base64(text_to_image(help_str)), encoding='utf-8')}"
        }
    }]))
    await help.finish("您也可以移步使用指南:\n https://blog.europix.icu/2022/08/25/eurobot/")
award = on_command('安慰分', aliases= {'奖励分'})


@award.handle()
async def _(bot: Bot, event: Event, state: T_State):
    award_str = '''安慰分机制：如果达到了这个分数线，会比本阶段分数(SSS或SS+)多1分奖励。
    
    定数     安慰分数线
    14.2    100.1565%
    14.3    100.4922% (?)
    14.4    100.3087%
    14.5    100.1278%
    14.6    100.4567%
    14.7    100.2772%  /  99.9794% (?)
    14.8    100.1002%  /  99.8158%
    14.9    100.4226%  /  99.6543%
    
实在吃不到分可以来试试吃安慰分orz
Generated by Eurobot'''

    await award.send(Message([{
        "type": "image",
        "data": {
            "file": f"base64://{str(image_to_base64(text_to_image(award_str)), encoding='utf-8')}"
        }
    }]))


async def _group_poke(bot: Bot, event: Event, state: dict) -> bool:
    value = (event.notice_type == "notify" and event.sub_type == "poke" and event.target_id == int(bot.self_id))
    return value


poke = on_notice(rule=_group_poke, priority=10, block=True)


@poke.handle()
async def _(bot: Bot, event: Event, state: T_State):
    if event.__getattribute__('group_id') is None:
        event.__delattr__('group_id')
    await poke.send(Message([{
        "type": "poke",
        "data": {
            "qq": f"{event.sender_id}"
        }
    }]))



def humanNum(num):
    if num < 10000:
        return num
    else:
        a = int(num)/10000
        b = re.findall(r"\d{1,}?\.\d{1}", str(a))
        return f'{b[0]}万'


def getVideoInfo(param_aid, param_bvid):
    if len(param_aid)> 0:
        url = f'https://api.bilibili.com/x/web-interface/view?aid={param_aid}&bvid={param_bvid}'
    else:
        url = f'https://api.bilibili.com/x/web-interface/view?bvid={param_bvid}'
    try:
        with requests.get(url, timeout=20) as resp:
            res = resp.json()
            data = res['data']
            bvid = data['bvid']
            aid = data['aid']
            pic = data['pic']
            title = data['title']
            name = data['owner']['name']
            view = data['stat']['view']
            danmaku = data['stat']['danmaku']
            play = humanNum(view)
            danku = humanNum(danmaku)
            cover = MessageSegment.image(pic)
            result = f'不要再发小程序了QAQ\n为了TIM和电脑端↓\nav{aid}\n{title}\nUP:{name}\n{play}播放 {danku}弹幕\nhttps://www.bilibili.com/video/{bvid}'.strip()
            return result,cover
    except Exception as ex:
        return None


def getSearchVideoInfo(keyword):
    url = f'https://api.bilibili.com/x/web-interface/search/all/v2?{keyword}'
    try:
        with requests.get(url, timeout=20) as resp:
            res = resp.json()
            data = res['data']['result']
            videos = [x for x in data if x['result_type'] == 'video']
            if (len(videos) == 0):
                return None
            video = videos[0]['data'][0]
            aid = video['aid']
            bvid = video['bvid']
            pic = video['pic']
            play = humanNum(video['play'])
            danku = humanNum(video['video_view'])
            title = html2text.html2text(video['title'])
            cover = MessageSegment.image(f'http://{pic}')
            author = video['author']
            result = f'不要再发小程序了QAQ\n为了TIM和电脑端↓\nav{aid}\n{title}\nUP:{author}\n{play}播放 {danku}弹幕\nhttps://www.bilibili.com/video/{bvid}'.strip()
            return result,cover
    except Exception as ex:
        return None


def getAvBvFromNormalLink(link):
    if isinstance(link, str) is False:
        return None
    search = re.findall(
        r'bilibili\.com\/video\/(?:[Aa][Vv]([0-9]+)|([Bb][Vv][0-9a-zA-Z]+))', link)
    if len(search) <= 0:
        return search
    result = {'aid': search[0][0], 'bvid': search[0][1]}
    return result


def getAvBvFromShortLink(link):
    try:
        with requests.head(link, timeout=20) as resp:
            status = resp.status_code
            if(status >= 200 and status < 400):
                location = resp.headers['location']
                normal_link = getAvBvFromNormalLink(location)
                return normal_link
            else:
                return None
    except Exception as ex:
        pass


def getAvBvFromMsg(msg):
    search = getAvBvFromNormalLink(msg)
    if len(search) > 0:
        return search
    search = re.findall(r'b23\.tv\/[a-zA-Z0-9]+', msg)
    if len(search) > 0:
        return getAvBvFromShortLink(f'http://{search[0]}')
    return None


def unescape(param):
    a = param.replace('#44;', ',')
    b = re.sub(r'&#91;', '[', a)
    c = re.sub(r'&#93;', ']', b)
    d = c.replace('\\/', '/')
    result = re.sub(r'&amp;', '&', d)
    return result


def match_msg(keyword, msg):
    return keyword in msg


sbilibili = on_message()

@sbilibili.handle()
async def _(bot: Bot, event: Event, state: T_State):
    msg = str(event.message)
    msg = unescape(msg)
    title = None
    is_pro = 0
    is_match1 = re.findall(r'\[CQ:xml,.*\]?\S*', msg)
    is_match2 = re.findall(r'\[CQ:json,.*\]?\S*', msg)
    keyword1 = '&#91;QQ小程序&#93;哔哩哔哩'
    keyword2 = 'QQ小程序'
    if len(is_match1) > 0:
        if match_msg(keyword1, msg) == True or match_msg(keyword2, msg) == True:
            #print('match！')
            is_pro = 1
            search = re.findall(r'<source url="(......................)', msg)
            shortLink = str(search[0])
            print(shortLink)
            NormalLink = getAvBvFromShortLink(shortLink)
            print(NormalLink)
            #result = getAvBvFromNormalLink(NormalLink)
            #print(result)
            if NormalLink is None:
                pass
            elif len(NormalLink) > 0:
                reply,cover = getVideoInfo(NormalLink['aid'], NormalLink['bvid'])
                if cover is not None:
                    await sbilibili.send(cover)
                if reply is not None:
                    await sbilibili.send(reply)
    elif len(is_match2) > 0 :            
        if match_msg(keyword1, msg) == True or match_msg(keyword2, msg) == True:
            #print('match！')
            is_pro = 1
            search = re.findall(r'"qqdocurl":"(......................)', msg)
            shortLink = str(search[0])
            print(shortLink)
            NormalLink = getAvBvFromShortLink(shortLink)
            print(NormalLink)
            #result = getAvBvFromNormalLink(NormalLink)
            #print(result)
            if NormalLink is None:
                pass
            elif len(NormalLink) > 0:
                reply,cover = getVideoInfo(NormalLink['aid'], NormalLink['bvid'])
                if cover is not None:
                    await sbilibili.send(cover)
                if reply is not None:
                    await sbilibili.send(reply)            
    else:
        pass