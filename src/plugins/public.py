import random
import re

from PIL import Image
from nonebot import on_command, on_message, on_notice, require, get_driver, on_regex, on_keyword, on_startswith
from nonebot.typing import T_State
from nonebot.adapters.cqhttp import Message, Event, Bot
from src.libraries.image import *
from random import randint
import requests
import html2text
from aiocqhttp.message import MessageSegment

help = on_command('!help')


@help.handle()
async def _(bot: Bot, event: Event, state: T_State):
    help_str = '''Eurobot 食用方法：
今日运势 :查看今天的舞萌运势
XXXmaiXXX什么 :随机一首歌
bp (为了分开不是b40) : 查询b40
例：bp Europix
随个[dx/标准][绿黄红紫白]<难度> :随机一首指定条件的乐曲
例：随个紫12
查歌<乐曲标题的一部分> :查询符合条件的乐曲
例：(!)查歌 起動音
[绿黄红紫白]id<歌曲编号> :查询乐曲信息或谱面信息
例：紫id220
<歌曲别名>是什么歌 :查询乐曲别名对应的乐曲
例：启动音是什么歌
定数查歌 <定数>  :查询定数对应的乐曲
例：(!)定数查歌 12.3
分数线 <难度+歌曲id> <分数线> 详情请输入“分数线 帮助”查看
例：!分数线 紫id220 100.50
!查分 <歌曲id> 可查询自己某歌分数 (需要在查分器绑定qq)
例：!查分 220 / !me 220
分数列表 <等级> （上下限） 可以输出某个等级某个范围内的分数列表
例： !filter 13 （13级的分数列表）
    !分数列表 13+ 100.0 （13+大于100的分数列表）
    !分数列表 14 99.90 100.00 （14级位于99.9和鸟之间的分数列表）
排行榜 <歌曲id> （难度） 可以输出某首歌 紫谱 的排行榜（本地）
例： 排行榜 220 （没有感叹号）
例： 排行榜 834 白
*注 排行榜会显示第一名的qq，和自己的分数，若介意可以联系主人删除数据
!update 更新自己的数据
例： !update
*注 如果想删除自己的数据请联系主人 qq759381653
石(凯，财，风) 数字/几 :可实时报告或追踪机厅人数
例：石 5/石 几
随机上/下/中/特级：模拟 Splash 随机段位四首歌
例: 随机上级
骂我/ 某地疫情 / 随个朱云杰 / 今天吃什么 / 神秘命令 Eurobot等你使用哦
 ------------------------------------------
Akatsuki Relax 查分 食用指南：
!rrc <玩家uid> 最近一次游玩结果（图片）
!rbp <bp多少> <玩家uid> 查询玩家的某个bp （图片）
!todaybp <玩家uid> 今天打出来的bp (1-100)
以上只用于 osu! Akatsuki 服的 relax 模式！
made by chiyuki & Europix  主人：深海少女吉安娜
version 2.0  updated on 2022.4.7'''

    await help.send(Message([{
        "type": "image",
        "data": {
            "file": f"base64://{str(image_to_base64(text_to_image(help_str)), encoding='utf-8')}"
        }
    }]))

award = on_command('安慰分', aliases= {'奖励分'})


@award.handle()
async def _(bot: Bot, event: Event, state: T_State):
    award_str = '''安慰分机制：如果达到了这个分数线，会比本阶段分数(SSS或SS+)多1分奖励。
    
    定数     安慰分数线
    14.2    100.1565%
    14.3    100.4922% (?)
    14.4    100.3087%
    14.5    100.1278%
    14.6    100.4567%
    14.7    100.2772%  /  99.9794% (?)
    14.8    100.1002%  /  99.8158%
    14.9    100.4226%  /  99.6543%
    
实在吃不到分可以来试试吃安慰分orz
Generated by Eurobot'''

    await award.send(Message([{
        "type": "image",
        "data": {
            "file": f"base64://{str(image_to_base64(text_to_image(award_str)), encoding='utf-8')}"
        }
    }]))


async def _group_poke(bot: Bot, event: Event, state: dict) -> bool:
    value = (event.notice_type == "notify" and event.sub_type == "poke" and event.target_id == int(bot.self_id))
    return value


poke = on_notice(rule=_group_poke, priority=10, block=True)


@poke.handle()
async def _(bot: Bot, event: Event, state: T_State):
    if event.__getattribute__('group_id') is None:
        event.__delattr__('group_id')
    await poke.send(Message([{
        "type": "poke",
        "data": {
            "qq": f"{event.sender_id}"
        }
    }]))



def humanNum(num):
    if num < 10000:
        return num
    else:
        a = int(num)/10000
        b = re.findall(r"\d{1,}?\.\d{1}", str(a))
        return f'{b[0]}万'


def getVideoInfo(param_aid, param_bvid):
    url = f'https://api.bilibili.com/x/web-interface/view?aid={param_aid}&bvid={param_bvid}'
    try:
        with requests.get(url, timeout=20) as resp:
            res = resp.json()
            data = res['data']
            bvid = data['bvid']
            aid = data['aid']
            pic = data['pic']
            title = data['title']
            name = data['owner']['name']
            view = data['stat']['view']
            danmaku = data['stat']['danmaku']
            play = humanNum(view)
            danku = humanNum(danmaku)
            # cover = MessageSegment.image(pic)
            result = f'不要再发小程序了QAQ\n为了TIM和电脑端↓\nav{aid}\n{title}\nUP:{name}\n{play}播放 {danku}弹幕\nhttps://www.bilibili.com/video/{bvid}'.strip()
            return result
    except Exception as ex:
        return None


def getSearchVideoInfo(keyword):
    url = f'https://api.bilibili.com/x/web-interface/search/all/v2?{keyword}'
    try:
        with requests.get(url, timeout=20) as resp:
            res = resp.json()
            data = res['data']['result']
            videos = [x for x in data if x['result_type'] == 'video']
            if (len(videos) == 0):
                return None
            video = videos[0]['data'][0]
            aid = video['aid']
            bvid = video['bvid']
            pic = video['pic']
            play = humanNum(video['play'])
            danku = humanNum(video['video_view'])
            title = html2text.html2text(video['title'])
            # cover = MessageSegment.image(f'http://{pic}')
            author = video['author']
            result = f'不要再发小程序了QAQ\n为了TIM和电脑端↓\nav{aid}\n{title}\nUP:{author}\n{play}播放 {danku}弹幕\nhttps://www.bilibili.com/video/{bvid}'.strip()
            return result
    except Exception as ex:
        return None


def getAvBvFromNormalLink(link):
    if isinstance(link, str) is False:
        return None
    search = re.findall(
        r'bilibili\.com\/video\/(?:[Aa][Vv]([0-9]+)|([Bb][Vv][0-9a-zA-Z]+))', link)
    if len(search) <= 0:
        return search
    result = {'aid': search[0][0], 'bvid': search[0][1]}
    return result


def getAvBvFromShortLink(link):
    try:
        with requests.head(link, timeout=20) as resp:
            status = resp.status_code
            if(status >= 200 and status < 400):
                location = resp.headers['location']
                normal_link = getAvBvFromNormalLink(location)
                return normal_link
            else:
                return None
    except Exception as ex:
        pass


def getAvBvFromMsg(msg):
    search = getAvBvFromNormalLink(msg)
    if len(search) > 0:
        return search
    search = re.findall(r'b23\.tv\/[a-zA-Z0-9]+', msg)
    if len(search) > 0:
        return getAvBvFromShortLink(f'http://{search[0]}')
    return None


def unescape(param):
    a = param.replace('#44;', ',')
    b = re.sub(r'&#91;', '[', a)
    c = re.sub(r'&#93;', ']', b)
    d = c.replace('\\/', '/')
    result = re.sub(r'&amp;', '&', d)
    return result


def match_msg(keyword, msg):
    return keyword in msg


sbilibili = on_message()

@sbilibili.handle()
async def _(bot: Bot, event: Event, state: T_State):
    msg = str(event.message)
    msg = unescape(msg)
    title = None
    is_match = re.findall(r'\[CQ:rich,.*\]?\S*', msg)
    keyword1 = '&#91;QQ小程序&#93;哔哩哔哩'
    keyword2 = '[[QQ小程序]哔哩哔哩]'
    if len(is_match) > 0:
        if match_msg(keyword1, msg) == True or match_msg(keyword2, msg) == True:
            search = re.findall(r'"desc":"(.+?)"', msg)
            if len(search) > 0:
                title = re.sub(r'/\\"/g', '"', search[1])
    param = getAvBvFromMsg(msg)
    if param is None:
        pass
    elif len(param) > 0:
        reply = getVideoInfo(param['aid'], param['bvid'])
        if reply is not None:
            await sbilibili.send(reply)
    isBangumi = re.search(
        r'bilibili\.com\/bangumi|(b23|acg)\.tv\/(ep|ss)', msg)
    if isinstance(title, str) and isBangumi:
        reply = getSearchVideoInfo(title)
        if reply is not None:
            await sbilibili.send(reply)